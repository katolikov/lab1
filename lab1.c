#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>
#include <unistd.h>
#include <wait.h>
sigjmp_buf obl; //область памяти для сохранения состояния процесса
void fun(){ //обработка прерывания
    printf(" \n");
    system("date"); //вывод времени(Позволяет запустить новый процесс в рамках уже выполняющегося процесса)
    siglongjmp(obl,1); //возвращение на sigsetjmp
}

int main(){
    int fd[2]; //дескрипторы межпроцессного канала куда записываются два пользовательских дескрип, 0 чтение, 1 запись
    int ret, s;
    char n[100];
    struct sigaction sa_new; //переменная  которой присваивается текущая маска процесса
    sa_new.sa_handler = fun; //при поступлении сигнала, указываем функцию его обработки
    sigprocmask(0,0,&sa_new.sa_mask); //блокировка сигналов (создание сигнальной маски)
    sa_new.sa_flags = 0; //флаги, управляющие доставкой сигнала
    sigaction(SIGINT,&sa_new,0); //метод обработка сигнала
    sigsetjmp(obl,1); //запоминание текущего состояния
    if(pipe(fd)==-1) //создание межпроцессного канала межпроцессорнойсвязи между двумя взаимосвязанными процессами
    {
        //sigsetjmp(obl,1); //запоминание текущего состояния
        printf("error\n");
        //sigsetjmp(obl,1); //запоминание текущего состояния(savesigs не равно нулю, то набор заблокированных сигналов сохраняется в env и будет восстановлен.)
        exit(1);
    }
    switch(fork()){ //распараллеливание процесса
        case -1: //ошибка
            perror("error");
            exit(1);
        case 0: //процесс сын
            close(fd[0]);
            dup2(fd[1],1); //дублирование дескриптора на стандартный вывод, fd[1] на строку в таблице 1
            execl("/usr/bin/users","users",NULL);//Запускает новую программу вместо уже выполняющейся без возврата вызывающей программы.
            exit(0);
        default:  //процесс родитель
            wait(&s); //ожидание окончания процесса сынка 15 бит, до 7 значение 0 если с exit() 7 байт 0 сохран, 1 не сохран, дальше аргумент функции exit
            sigsetjmp(obl,1); //запоминание текущего состояния
            ret = read(fd[0],n,99);//считывают 99 байтов из буфера n, куда читается из fd[0]
            n[ret] = '\0';//конец строки записываем
            sigsetjmp(obl,1); //запоминание текущего состояния
            printf("\nUsers:");
            printf("%s",n); //вывод строки
            sigsetjmp(obl,1); //запоминание текущего состояния
    }
    sigsetjmp(obl,1); //запоминание текущего состояния
    sleep(5);
    return 0;
}



